//CYK algorithm
/*
S -> AB
A -> AB | a
B -> CC | B
C -> AC | a

string to be found

1. separate left hand and right hand productions
2. Check for CNF
3. Build the matrix


INPUT : 
S
4
S->AB
A->AB|a
B->BC|b
C->AC|a
ababba

*/

# include <bits/stdc++.h>
using namespace std;

#define MAX 105

string grammar [MAX][MAX];
string productions[MAX];

int subparts,no_of_productions;

string concat(string a, string b)
{
	string r = a;
	for(int i = 0; i < b.length(); i++)
		{
			if(r.find(b[i]) > r.length())
			{
				r += b[i];
			}
		}
	
	return (r);
}

void break_grammar(string a)
{
	int ptr;
	subparts = 0;

	while(a.length() > 0)
	{
		ptr = a.find("|");
		
		if(ptr > a.length())
			{
				productions[subparts++] = a;
				a = "";
			}
		else
			{
				productions[subparts++] = a.substr(0,ptr);
				a = a.substr(ptr+1,a.length());
			}
		
	}
	
	
}

int lchomsky(string a)
{
	if(a.length() == 1 && a[0] >= 'A' && a[0] <= 'Z')
	return 1;
	
	return 0;
	
}

int rchomsky(string a)
{
	if(a.length() == 1 && a[0] >= 'a' && a[0] <= 'z')
		return 1;
	
	if(a.length() == 2 && a[0] >= 'A' && a[0] <= 'Z')
		return 1;
}

string search_productions(string p)
{
	string r = "";
	int k;
	for(int i = 0 ; i < no_of_productions; i++)
	{
		k = 1;
		
		while(grammar[i][k] != "")
			{
				if(grammar[i][k] == p)
				{
					r = concat(r,grammar[i][0]);
				}
				k++;
			}
	}
	
	return r;
}

string gen_comb(string a,string b)
{
	string pri = a, re = "";
	
	for(int i = 0; i < a.length(); i ++)
		{
			for( int j = 0; j < b.length(); j ++)
			{
				 pri = "";
				 pri = pri + a[i] + b[j];
				 re = re + search_productions(pri);
			}
			
		}
	return re;
}


int main()
{

	string start;
	cout<< " \n*****Enter the start variable (like S) *****" << endl;
	cin >> start;
	
	cout<< "\n*****Enter the number of productions****\n";
	cin >> no_of_productions;
	
	string produce;
	int ptr;
	
	cout<< "\n****Enter the productions****\n";
	for(int i = 0; i < no_of_productions; i++)
	{
		cin >> produce;
		ptr = produce.find("->");
		
		grammar[i][0] = produce.substr(0,ptr);
		
		if(lchomsky(grammar[i][0]) == 0)
			{
				cout << "Entered production is not in Chomsky's Normal Form \n";
				exit(0);
			}
		
		produce = produce.substr(ptr + 2, produce.length());
		break_grammar(produce);
		
		for(int j = 0; j < subparts ; j++)
			{
				grammar[i][j+1] = productions[j];
				
				if(rchomsky(productions[j]) == 0)
				{
					cout << "Entered production is not in Chomsky's Normal Form \n";
					exit(0);
				}
			}
	}
	
	string CYK[MAX][MAX],str,r,st,pr;
	
	cout << "\n****Enter the string to be searched****\n";
	cin >> str;
	int k = 0;
	
	for(int i = 0 ; i < str.length(); i++)
	{
		r = "";
		st = "";
		st += str[i];
		
		for(int j = 0; j < no_of_productions; j++)
		{
			k =1;
				while(grammar[j][k] != "")
				{	
					if(grammar[j][k] == st)
						{
							r = concat(r,grammar[j][0]);
						}
					k++;
				}
		}
		
		CYK[i][i] = r;
		
	}
	
	for(int k = 1 ; k < str.length(); k++)
	{
		for(int j = k; j < str.length(); j++)
		{
			 r ="";
			 
			 for( int l = j-k; l < j; l++)
			 {
			 	
				pr = gen_comb(CYK[j-k][l] , CYK[l+1][j]);
				r  = concat(r,pr);
			 }
			
			CYK[j-k][j] = r;	
		}
		
	}
	
	int l;
	// print the CYK matrix
	for(int i = 0; i < str.length(); i++)
	{ 
		k = 0;
		l = str.length()-i-1;
		
		for(int j = l ; j < str.length(); j++)
			{
				cout << setw(5) << CYK[k++][j] << " ";
			}
		cout << endl;
	}
	
	
	for(int i =0; i < start.length();i++)
	{
		if(CYK[0][str.length()-1].find(start[i]) <= CYK[0][str.length()-1].length())
			{
				cout << "\n\n********String can be generated by the given Context Free Grammar";
			}
		else
		{
			cout << "\n\n********String cannot be generated by the given Context Free Grammar\n";
		}
	}
	
	return 0;
}
